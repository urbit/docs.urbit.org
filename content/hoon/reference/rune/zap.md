# ! zap · Wild

## `!,` "zapcom" {#zapcom}

Produce the Hoon AST of an expression.

#### Syntax

Two arguments, fixed.

{% tabs %}

{% tab title="Tall form" %}

```hoon
!,  p
q
```

{% endtab %}

{% tab title="Wide form" %}

```hoon
!,(p q)
```

{% endtab %}

{% tab title="Irregular form" %}

None

{% endtab %}

{% endtabs %}

#### AST

```hoon
[%zpcm p=hoon q=hoon]
```

#### Discussion

This produces the [`$hoon`](../stdlib/4o.md#hoon) AST of expression `q`. The first argument, `p`, is always an example of the `$hoon` type, typically just the `*hoon` bunt value, and is used for type inference. The reason for `p` is just to handle transitions if the `$hoon` type changes.

#### Examples

```
> !,  *hoon  [1 1]
[%cltr p=~[[%sand p=%ud q=1] [%sand p=%ud q=1]]]

> !,  *hoon  (add 1 1)
[%cncl p=[%wing p=~[%add]] q=~[[%sand p=%ud q=1] [%sand p=%ud q=1]]]
```

---

## `!>` "zapgar" {#zapgar}

Wrap a noun in its type (form a [`vase`](../stdlib/4o.md#vase)).

#### Syntax

One argument, fixed.

| Tall form | Wide form | Irregular form |
|-----------|-----------|----------------|
| `!>  p`   | `!>(p)`   | None           |

#### AST

```hoon
[%zpgr p=hoon]
```

#### Produces

A cell whose tail is the product of `p`, and whose head is the static type of `p`.

#### Discussion

In Hoon, a dynamic type is a static type compiled at runtime. This type-noun cell is generally called a [`vase`](../stdlib/4o.md#vase).

#### Examples

```
> !>(1)
[#t/@ud q=1]
```

If you want just the type value, use a 'type spear'. This is `-:!>`, i.e., the head of the cell produced by `!>`:

```
> -:!>(1)
#t/@ud
```

---

## `!<` "zapgal" {#zapgal}

Extracts a [`vase`](../stdlib/4o.md#vase) to the given mold if its type nests.

#### Syntax

Two arguments, fixed.

{% tabs %}

{% tab title="Tall form" %}

```hoon
!<  p
q
```

{% endtab %}

{% tab title="Wide form" %}

```hoon
!<(p q)
```

{% endtab %}

{% tab title="Irregular form" %}

None

{% endtab %}

{% endtabs %}

#### AST

```hoon
[%zpgl p=spec q=hoon]
```

#### Produces

The value of vase `q` typed with the type of mold `p` if possible, else a `nest-fail`.

#### Discussion

This is something like a partial inverse to the `!>` rune and can be used to extract a typed value from a `vase`.

#### Examples

```
> !<  @  !>  ~zod
0

> !<  @p  !>  0
nest-fail

> !<  tape  !>("foobar")
"foobar"
```

---

## `!;` "zapmic" {#zapmic}

Wrap a noun in its type (raw).

#### Syntax

Two arguments, fixed.

{% tabs %}

{% tab title="Tall form" %}

```hoon
!;  p
q
```

{% endtab %}

{% tab title="Wide form" %}

```hoon
!;(p q)
```

{% endtab %}

{% tab title="Irregular form" %}

None

{% endtab %}

{% endtabs %}

#### AST

```hoon
[%zpmc p=hoon q=hoon]
```

#### Discussion

This wraps the product of `q` in its inferred type. It's a raw version of [`!>`](#-zapgar). Unlike zapgar, `q` is not given a `p` face and its type information is not stripped to a raw noun.

The first field, `p`, must be an example of the [`$type`](../stdlib/4o.md#type) type, typically just `*type` (the bunt of `$type`). The `p` argument is just so transitions can be handled if the `$type` type changes.

It's unlikely you'd use this rune directly; [`!>`](#-zapgar) is much more typical.

#### Examples

```
> !;  *type  [1 1]
[#t/[@ud @ud] 1 1]

> !;  *type  'foo'
[#t/@t 'foo']
```

---

## `!=` "zaptis" {#zaptis}

Make the Nock formula for a Hoon expression.

#### Syntax

One argument, fixed.

{% tabs %}

{% tab title="Tall form" %}

```hoon
!=  p
```

{% endtab %}

{% tab title="Wide form" %}

```hoon
!=(p)
```

{% endtab %}

{% tab title="Irregular form" %}

None

{% endtab %}

{% endtabs %}

#### AST

```hoon
[%zpts p=hoon]
```

#### Produces

The Nock generated by `p`.

#### Discussion

Don't confuse `!=` with a negation, `!`, followed by a test for equality, `=(10 11)`.

#### Examples

```
> !=(20)
[1 20]

> !=(~zod)
[1 0]

> !=((add 2 2))
[8 [9 3.110.356 0 31] 9 2 [0 4] [7 [0 3] 1 2 2] 0 11]
```

Don't confuse the `!=` rune with:

```
> !=(10 11)
%.y

> !=(10 10)
%.n
```

The syntax difference is that a test for equality takes two subexpressions, and the `!=` rune only one.

---

## `!?` "zapwut" {#zapwut}

Restrict Hoon version.

#### Syntax

Two arguments, fixed.

{% tabs %}

{% tab title="Tall form" %}

```hoon
!?  p
q
```

{% endtab %}

{% tab title="Wide form" %}

```hoon
!?(p q)
```

{% endtab %}

{% tab title="Irregular form" %}

None

{% endtab %}

{% endtabs %}

#### AST

```hoon
[%zpwt p=$@(p=@ [p=@ q=@]) q=hoon]
```

#### Produces

When `p` is an atom:

- `q` if `p` ≥ Hoon kelvin version, otherwise crash.

When `p` is a cell:

- `q`, if `p.p` ≥ Hoon kelvin version ≥ `q.p`, otherwise crash.

(Versions count down; the current version is 140.)

#### Examples

```
> !?  [142 140]  (add 2 2)
4

> !?  142  (add 2 2)
4

> !?  64  (add 2 2)
! exit
```

---

## `!@` "zappat" {#zappat}

Branch on whether a wing exists.

#### Syntax

Three arguments, fixed.

{% tabs %}

{% tab title="Tall form" %}

```hoon
!@  p
  q
r
```

{% endtab %}

{% tab title="Wide form" %}

```hoon
!@(p q r)
```

{% endtab %}

{% tab title="Irregular form" %}

None

{% endtab %}

{% endtabs %}

#### AST

```hoon
[%zppt p=(list wing) q=hoon r=hoon]
```

#### Discussion

`p` is a wing reference like `foo`, `bar.foo`, etc. If `p` exists, `q`. If `p` does not exist, `r`. Essentially, this is like `?:` for wing existence.

#### Examples

```
> =foo 42

> !@(foo 'exists' 'does not exist')
'exists'

> !@(baz 'exists' 'does not exist')
'does not exist'
```

---

## `!!` "zapzap" {#zapzap}

Crash.

#### Syntax

No arguments.

| Tall form | Wide form | Irregular form |
|-----------|-----------|----------------|
| `!!`      | `!!`      | None           |

#### AST

```hoon
[%zpzp ~]
```

#### Produces

Nothing. Always crashes, with type `%void`.

#### Discussion

`%void` nests in every other type, so you can stub out anything with `!!`.

#### Examples

```
> !!
dojo: hoon expression failed
```

---

## `!:` "zapcol" {#zapcol}

Turn on stack trace.

#### Syntax

One argument, fixed

| Tall form | Wide form | Irregular form |
|-----------|-----------|----------------|
| `!:  p`   | `!:(p)`   | None           |

#### Produces

The product of `p` unless `p` crashes, in which case a stack trace is given.

#### Discussion

`!:` is used to turn on a debugging stack trace option for any code you have in
`p`.

#### Examples

```
> ?:(=(0 1) 123 !!)
dojo: hoon expression failed

> !:  ?:(=(0 1) 123 !!)
/~zod/base/~2022.4.2..08.54.53..07d7:<[1 5].[1 22]>
/~zod/base/~2022.4.2..08.54.53..07d7:<[1 19].[1 21]>
dojo: hoon expression failed
```

---

## `!.` "zapdot" {#zapdot}

Turn off stack trace for a subexpression `p`

#### Syntax

One argument, fixed.

| Tall form | Wide form | Irregular form |
|-----------|-----------|----------------|
| `!.  p`   | `!.(p)`   | None           |

#### Produces

The product of `p`. If `p` crashes, no stack trace entries are given for that code.

#### Discussion

`!.` is used to turn off a debugging stack trace option for any code you have in `p`. This rune can be embedded under a `!:` rune for inner loops of your code that you don't want or need to trace. This is especially useful if a trace overflows the stack.

#### Examples

```
> %.(1 |=(a=@ ^-(@ ?:(=(a 10) !! $(a +(a))))))
dojo: hoon expression failed

> !:  %.(1 |=(a=@ ^-(@ ?:(=(a 10) !! $(a +(a))))))
/~zod/base/~2022.4.2..08.56.45..5ecc:<[1 5].[1 49]>
/~zod/base/~2022.4.2..08.56.45..5ecc:<[1 17].[1 47]>
/~zod/base/~2022.4.2..08.56.45..5ecc:<[1 22].[1 46]>
...skipping some lines...
/~zod/base/~2022.4.2..08.56.45..5ecc:<[1 22].[1 46]>
/~zod/base/~2022.4.2..08.56.45..5ecc:<[1 33].[1 35]>
dojo: hoon expression failed

> !:  %.(1 !.(|=(a=@ ^-(@ ?:(=(a 10) !! $(a +(a)))))))
/~zod/base/~2022.4.2..08.57.07..d40b:<[1 5].[1 53]>
dojo: hoon expression failed
```

---
