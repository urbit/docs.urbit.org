---
description: "Hoon language parser with core parsing functions and rules for syntax analysis."
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# 5d: Parser

## `+vang` {#vang}

Set `++vast` parameters

#### Source

```hoon
++  vang                                                ::  set ++vast params
  |=  [bug=? wer=path]                                  ::  bug: debug mode
  %*(. vast bug bug, wer wer)                           ::  wer: where we are
```

---

## `+vast` {#vast}

Main parsing core

### Source {#source}

This core is too large to include here, please refer to `hoon.hoon` for the source.

---

### `++vest` {#vest}

Parse hoon

Parsing `rule`. Parse hoon of any form.

#### Source

```hoon
++  vest
  ~/  %vest
  |=  tub=nail
  ^-  (like hoon)
  %.  tub
  %-  full
  (ifix [gay gay] tall:vast)
```

#### Examples

```
> (rash '(add 1 1)' vest)
[%cncl p=[%wing p=~[%add]] q=~[[%sand p=%ud q=1] [%sand p=%ud q=1]]]

> (rash '%+  add\0a  1\0a1' vest)
[%cnls p=[%wing p=~[%add]] q=[%sand p=%ud q=1] r=[%sand p=%ud q=1]]
```

---

### `++vice` {#vice}

Parse wide-form hoon

Parse `txt`, a `knot` containing wide-form hoon, to `hoon`.

#### Accepts

`txt` is a `@ta`.

#### Produces

`hoon`.

#### Source

```hoon
++  vice
  |=  txt=@ta
  ^-  hoon
  (rash txt wide:vast)
```

#### Examples

```
> (vice '(add 1 1)')
[%cncl p=[%wing p=~[%add]] q=~[[%sand p=%ud q=1] [%sand p=%ud q=1]]]

> (vice '%+  add\0a  1\0a1')
{1 3}
syntax error
```

---

## `+make` {#make}

Compile cord to nock

Compile `txt`, an `atom` containing hoon source code as little-endian UTF-8 text, to `nock`.

#### Accepts

`txt` is a `@`.

#### Produces

`nock`.

#### Source

```hoon
++  make
  |=  txt=@
  q:(~(mint ut %noun) %noun (ream txt))
```

#### Examples

```
> (make '[. . .]')
[p=[%0 p=1] q=[p=[%0 p=1] q=[%0 p=1]]]

> .*(42 (make '[. . .]'))
[42 42 42]
```

---

## `+rain` {#rain}

Parse with % path

Parse `txt`, an `atom` containing hoon source code as little-endian UTF-8 text, to `hoon`. Any `%` path short-hands are replaced with the path given in `bon`. If parsing fails, `bon` is also printed to the terminal.

#### Accepts

`bon` is a `path`.

`txt` is an atom.

#### Produces

`hoon`.

#### Source

```hoon
++  rain
  |=  [bon=path txt=@]
  ^-  hoon
  =+  vaz=vast
  ~|  bon
  (scan (trip txt) (full (ifix [gay gay] tall:vaz(wer bon))))
```

#### Examples

```
> (rain /a/b/c '%')
[%clsg p=~[[%sand p=%ta q=97] [%sand p=%ta q=98] [%sand p=%ta q=99]]]

> !<(path (slap !>(~) (rain /a/b/c '%')))
/a/b/c

> (rain / '(add 1 1)')
[%cncl p=[%wing p=~[%add]] q=~[[%sand p=%ud q=1] [%sand p=%ud q=1]]]

> !<(@ud (slap !>(add=add) (rain / '(add 1 1)')))
2
```

---

## `+ream` {#ream}

Parse cord to hoon

Parse `txt`, an `atom` containing hoon source code as little-endian UTF-8 text, to `hoon`.

#### Accepts

`txt` is an atom.

#### Produces

`hoon`.

#### Source

```hoon
++  ream
  |=  txt=@
  ^-  hoon
  (rash txt vest)
```

#### Examples

```
> !<(tape (slap !>(~) (ream '"foobar"')))
"foobar"
```

---

## `+reck` {#reck}

Parse hoon file

Parse `bon` to `hoon`. `bon` is a `path` to a .hoon file without the mark.

#### Accepts

`bon` is a `path`.

#### Produces

`hoon`.

#### Source

```hoon
++  reck
  |=  bon=path
  (rain bon .^(@t %cx (weld bon `path`[%hoon ~])))
```

#### Examples

```
> (reck %/gen/code)
[ %clhp
  p=[%rock p=%tas q=7.954.803]
    q
  [ %brts
      p
    [ %bccl
        p
      [   i
        [ %bccl
            p
          [   i
            [%bcts p=term=%now q=[%base p=[%atom p=~.da]]]
              t
......(truncated for brevity)..........
```

---

## `+ride` {#ride}

End-to-end compiler

Parse and compile cord `txt`, producing a pair of its `type` and compiled `nock`. The `typ` argument specifies the `type` of the subject.

#### Accepts

`typ` is a `type`

`txt` is an atom.

#### Produces

A `(pair type nock)`.

#### Source

```hoon
++  ride
  |=  [typ=type txt=@]
  ^-  (pair type nock)
  ~>  %slog.[0 leaf/"ride: parsing"]
  =/  gen  (ream txt)
  ~>  %slog.[0 leaf/"ride: compiling"]
  ~<  %slog.[0 leaf/"ride: compiled"]
  (~(mint ut typ) %noun gen)
```

#### Examples

```
ride: parsing
ride: compiling
ride: compiled
> (ride -:!>(.) '(add 2 2)')
[ #t/@
    q
  [ %8
    p=[%9 p=36 q=[%0 p=1.023]]
      q
    [ %9
      p=2
        q
      [ %10
          p
        [ p=6
            q
          [ p=[%7 p=[%0 p=3] q=[%1 p=2]]
            q=[%7 p=[%0 p=3] q=[%1 p=2]]
          ]
        ]
        q=[%0 p=2]
      ]
    ]
  ]
]

ride: parsing
ride: compiling
> (ride %noun '(add 2 2)')
-find.add
dojo: hoon expression failed
```

---
