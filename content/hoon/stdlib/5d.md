---
description: "Hoon language parser with core parsing functions and rules for syntax analysis."
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# 5d: Parser

## `+vang` {#vang}

Set `+vast` parameters.

#### Source

```hoon
++  vang                                                ::  set ++vast params
  |=  [bug=? wer=path]                                  ::  bug: debug mode
  %*(. vast bug bug, wer wer)                           ::  wer: where we are
```

---

## `+vast` {#vast}

Main parsing core.

### Source {#source}

This core is too large to include here, please refer to `hoon.hoon` for the source.

---

### `+vest` {#vest}

Parse Hoon.

Parsing `$rule`. Parse Hoon of any form.

#### Source

```hoon
++  vest
  ~/  %vest
  |=  tub=nail
  ^-  (like hoon)
  %.  tub
  %-  full
  (ifix [gay gay] tall:vast)
```

#### Examples

```
> (rash '(add 1 1)' vest)
[%cncl p=[%wing p=~[%add]] q=~[[%sand p=%ud q=1] [%sand p=%ud q=1]]]
```

```
> (rash '%+  add\0a  1\0a1' vest)
[%cnls p=[%wing p=~[%add]] q=[%sand p=%ud q=1] r=[%sand p=%ud q=1]]
```

---

### `+vice` {#vice}

Parse wide-form Hoon.

Parse `.txt`, a `$knot` containing wide-form Hoon, to `$hoon`.

#### Accepts

`.t` is a `@ta`.

#### Produces

`$hoon`.

#### Source

```hoon
++  vice
  |=  txt=@ta
  ^-  hoon
  (rash txt wide:vast)
```

#### Examples

```
> (vice '(add 1 1)')
[%cncl p=[%wing p=~[%add]] q=~[[%sand p=%ud q=1] [%sand p=%ud q=1]]]
```

```
> (vice '%+  add\0a  1\0a1')
{1 3}
syntax error
```

---

## `+make` {#make}

Compile `$cord` to Nock.

Compile `.txt`, an `$atom` containing Hoon source code as little-endian UTF-8 text, to `$nock`.

#### Accepts

`.t` is a `@`.

#### Produces

`$nock`.

#### Source

```hoon
++  make
  |=  txt=@
  q:(~(mint ut %noun) %noun (ream txt))
```

#### Examples

```
> (make '[. . .]')
[p=[%0 p=1] q=[p=[%0 p=1] q=[%0 p=1]]]
```

```
> .*(42 (make '[. . .]'))
[42 42 42]
```

---

## `+rain` {#rain}

Parse with % path.

Parse `.txt`, an `$atom` containing Hoon source code as little-endian UTF-8 text, to `$hoon`. Any `%` path short-hands are replaced with the path given in `.bon`. If parsing fails, `.n` is also printed to the terminal.

#### Accepts

`.n` is a `$path`.

`.t` is an `$atom`.

#### Produces

`$hoon`.

#### Source

```hoon
++  rain
  |=  [bon=path txt=@]
  ^-  hoon
  =+  vaz=vast
  ~|  bon
  (scan (trip txt) (full (ifix [gay gay] tall:vaz(wer bon))))
```

#### Examples

```
> (rain /a/b/c '%')
[%clsg p=~[[%sand p=%ta q=97] [%sand p=%ta q=98] [%sand p=%ta q=99]]]
```

```
> !<(path (slap !>(~) (rain /a/b/c '%')))
/a/b/c
```

```
> (rain / '(add 1 1)')
[%cncl p=[%wing p=~[%add]] q=~[[%sand p=%ud q=1] [%sand p=%ud q=1]]]
```

```
> !<(@ud (slap !>(add=add) (rain / '(add 1 1)')))
2
```

---

## `+ream` {#ream}

Parse `$cord` to Hoon.

Parse `.txt`, an `$atom` containing Hoon source code as little-endian UTF-8 text, to `$hoon`.

#### Accepts

`.t` is an `$atom`.

#### Produces

`$hoon`.

#### Source

```hoon
++  ream
  |=  txt=@
  ^-  hoon
  (rash txt vest)
```

#### Examples

```
> !<(tape (slap !>(~) (ream '"foobar"')))
"foobar"
```

---

## `+reck` {#reck}

Parse Hoon file.

Parse `.n` to `$hoon`. `.n` is a `$path` to a .hoon file without the mark.

#### Accepts

`.n` is a `$path`.

#### Produces

`$hoon`.

#### Source

```hoon
++  reck
  |=  bon=path
  (rain bon .^(@t %cx (weld bon `path`[%hoon ~])))
```

#### Examples

```
> (reck %/gen/code)
[ %clhp
  p=[%rock p=%tas q=7.954.803]
    q
  [ %brts
      p
    [ %bccl
        p
      [   i
        [ %bccl
            p
          [   i
            [%bcts p=term=%now q=[%base p=[%atom p=~.da]]]
              t
......(truncated for brevity)..........
```

---

## `+ride` {#ride}

End-to-end compiler.

Parse and compile `$cord` `.txt`, producing a pair of its `$type` and compiled `$nock`. The `.p` argument specifies the `$type` of the subject.

#### Accepts

`.p` is a `$type`

`.t` is an `$atom`.

#### Produces

A `(pair type nock)`.

#### Source

```hoon
++  ride
  |=  [typ=type txt=@]
  ^-  (pair type nock)
  ~>  %slog.[0 leaf/"ride: parsing"]
  =/  gen  (ream txt)
  ~>  %slog.[0 leaf/"ride: compiling"]
  ~<  %slog.[0 leaf/"ride: compiled"]
  (~(mint ut typ) %noun gen)
```

#### Examples

```
ride: parsing
ride: compiling
ride: compiled
> (ride -:!>(.) '(add 2 2)')
[ #t/@
    q
  [ %8
    p=[%9 p=36 q=[%0 p=1.023]]
      q
    [ %9
      p=2
        q
      [ %10
          p
        [ p=6
            q
          [ p=[%7 p=[%0 p=3] q=[%1 p=2]]
            q=[%7 p=[%0 p=3] q=[%1 p=2]]
          ]
        ]
        q=[%0 p=2]
      ]
    ]
  ]
]

ride: parsing
ride: compiling

> (ride %noun '(add 2 2)')
-find.add
dojo: hoon expression failed
```

---
