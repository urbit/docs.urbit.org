# Command-Line Apps

## Introduction {#introduction}

In this walkthrough we will go in-depth on how to build command line interface (CLI) applications in Urbit using the `shoe` library.

There are three CLI apps that currently ship with urbit - `%dojo`, `%chat-cli`, and `%shoe`. You should be familiar with the former two, the latter is an example app that shows off how the `shoe` library works that we will be looking at closely. These are all Gall apps, and their source can be found in the `app/` folder of your `%base` desk.

In [the `shoe` library](#the-shoe-library) we take a closer look at the `shoe` library and its cores and how they are utilized in CLI apps. Then in [the `sole` library](#the-sole-library) we look at what `shoe` effects ultimately break down into. Finally in [`%shoe` app walkthrough](#shoe-app-walkthrough) we explore the functionality of the `%shoe` app and then go through the code line-by-line.

This tutorial can be considered to be an application equivalent of the [Hoon school lesson](../../../courses/hoon-school/P-stdlib-io.md#ask-generators) on `sole` and `%ask` generators, which only covers the bare minimum necessary to write generators that take user input.

## The `shoe` library {#the-shoe-library}

Here we describe how sessions are identified, the specialized `card`s that Gall agents with the `shoe` library are able to utilize, and the different cores of `/lib/shoe.hoon` and their purpose.

### Session identifiers {#session-identifiers}

An app using the `shoe` library will automatically track sessions by their `sole-id`. A `sole-id` is made up of a "host" ship name and some identifier string. Generally, however, the `sole-id` as a whole should be treated as an opaque identifier, generated by the connecting client. An app using the `shoe` library may be connected to by a local or remote ship in order to send commands, and each of these connections is assigned a unique `sole-id` that identifies the ship and which session on that ship if there are multiple.

### `%shoe` `card`s {#shoe-cards}

Gall agents with the `shoe` library are able to utilize `%shoe` `card`s. These additions to the standard set of `cards` have the following shape:

{% code title="/lib/shoe.hoon" overflow="nowrap" %}

```hoon
[%shoe sole-ids=(list sole-id) effect=shoe-effect]
```

{% endcode %}

`sole-ids` is the `list` of session ids that the following `effect` is emitted to. An empty `sole-ids` sends the effect to all connected sessions. `shoe-effect`s, for now, are always of the shape `[%sole effect=sole-effect]`, where `sole-effect`s are basic console events such as displaying text, changing the prompt, beeping, etc. These are described in the section on the [`sole` library](#the-sole-library).

For example, a `%shoe` `card` that causes all connected sessions to beep would be `[%shoe ~ %sole %bel ~]`.

### `shoe` core {#shoe-core}

An iron (contravariant) door that defines an interface for Gall agents utilizing the `shoe` library. Use this core whenever you want to receive input from the user and run a command. The input will get put through the parser (`+command-parser`) and results in a noun of `command-type` that the underlying application specifies, which shoe then feeds back into the underlying app as an `+on-command` callback.

In addition to the ten arms that all Gall core apps possess, `+shoe` defines and expects a few more, tailored to common CLI logic. Thus you will need to wrap the `shoe:shoe` core using the `agent:shoe` function to obtain a standard 10-arm Gall agent core. See the [shoe example app walkthrough](#shoe-example-app-walkthrough) for how to do this.

The additional arms are described below. The Hoon code shows their expected type signature. As we'll see [later](#shoe-app-walkthrough), the `command-type` can differ per application. Note also that most of these take a session identifier as an argument. This lets applications provide different users (at potentially different "places" within the application) with different affordances.

#### `+command-parser`

{% code title="/lib/shoe.hoon" overflow="nowrap" %}

```hoon
  ++  command-parser
    |~  =sole-id
    |~(nail *(like [? command-type]))
```

{% endcode %}

Input parser for a specific command-line session. Will be run on whatever the user tries to input into the command prompt, and won't let them type anything that doesn't parse. If the head of the result is true, instantly run the command. If it's false, require the user to press return.

#### `+tab-list`

{% code title="/lib/shoe.hoon" overflow="nowrap" %}

```hoon
  ++  tab-list
    |~  =sole-id
    *(list (option:auto tank))
```

{% endcode %}

Autocomplete options for the command-line session (to match `+command-parser`).

#### `+on-command`

{% code title="/lib/shoe.hoon" overflow="nowrap" %}

```hoon
  ++  on-command
    |~  [=sole-id command=command-type]
    *(quip card _this)
```

{% endcode %}

Called when a valid command is run.

#### `+can-connect`

{% code title="/lib/shoe.hoon" overflow="nowrap" %}

```hoon
  ++  can-connect
    |~  =sole-id
    *?
```

{% endcode %}

Called to determine whether a session may be opened or connected to. For example, you may only want the local ship to be able to connect.

#### `+on-connect`

{% code title="/lib/shoe.hoon" overflow="nowrap" %}

```hoon
  ++  on-connect
    |~  =sole-id
    *(quip card _^|(..on-init))
```

{% endcode %}

Called when a session is opened or connected to.

#### `+on-disconnect`

{% code title="/lib/shoe.hoon" overflow="nowrap" %}

```hoon
  ++  on-disconnect
    |~  =sole-id
    *(quip card _^|(..on-init))
```

{% endcode %}

Called when a previously made session gets disconnected from.

### `default` core {#default-core}

This core contains the bare minimum implementation of the additional `shoe` arms beyond the 10 standard Gall app ams. It is used analogously to how the `default-agent` core is used for regular Gall apps.

### `agent` core {#agent-core}

This is a function for wrapping a `shoe` core, which has too many arms to be a valid Gall agent core. This turns it into a standard Gall agent core by integrating the additional arms into the standard ones.

## The `sole` library {#the-sole-library}

`shoe` apps may create specialized `card`s of the `[%shoe (list sole-id) shoe-effect]` shape, where `shoe-effect` currently just wrap `sole-effect`s, i.e. instructions for displaying text and producing other effects in the console.

The list of possible `sole-effects` can be found in `/sur/sole.hoon`. A few commonly used ones are as follows.

- `[%txt tape]` is used to display a line of text.
- `[%bel ~]` is used to emit a beep.
- `[%pro sole-prompt]` is used to set the prompt.
- `[%mor (list sole-effect)]` is used to emit multiple effects.

For example, a `sole-effect` that displays `This is some text.` and beeps would be structured as

```hoon
[%mor [%txt "This is some text."] [%bel ~] ~]
```

## `%shoe` app walkthrough {#shoe-app-walkthrough}

Here we explore the capabilities of the `%shoe` example app and then go through the code, explaining what each line does.

### Playing with `%shoe` {#playing-with-shoe}

First let's test the functionality of `%shoe` so we know what we're getting into.

Start two fake ships, one named `~zod` and the other can have any name - we will go with `~nus`. Fake ships run locally are able to see each other, and our intention is to connect their `%shoe` apps.

On each fake ship start `%shoe` by entering `|start %shoe` into dojo. Now that the agent is running, you can run `|dojo/link %shoe` to connect to its cli interface. This will change the prompt to `~zod:shoe>` and `~nus:shoe>`. Type `demo` and watch the following appear:

{% code title="Dojo" overflow="nowrap" %}

```
~zod ran the command
~zod:shoe>
```

{% endcode %}

`~zod ran the command` should be displayed in bold green text, signifying that the command originated locally.

Now we will connect the sessions. Switch `~zod` back to dojo with `Ctrl-X` and enter `|dojo/link ~nus %shoe`. If this succeeds you will see the following.

{% code title="Dojo" overflow="nowrap" %}

```
>=
; ~nus is your neighbor
[linked to [p=~nus q=%shoe]]
```

{% endcode %}

Now `~zod` will have two `%shoe` sessions running - one local one on `~zod` and one remote one on `~nus`, which you can access by pressing `Ctrl-X` until you see `~nus:shoe>` from `~zod`'s console. On the other hand, you should not see `~zod:shoe>` on `~nus`'s side, since you have not connected `~nus` to `~zod`'s `%shoe` app. When you enter `demo` from `~nus:shoe>` on `~zod`'s console you will again see `~zod ran the command`, but this time it should be in the ordinary font used by the console, signifying that the command is originating from a remote session. Contrast this with entering `demo` from `~nus:shoe>` in `~nus`'s console, which will display `~nus ran the command` in bold green text.

Now try to link to `~zod`'s `%shoe` session from `~nus` by switching to the dojo on `~nus` and entering `|dojo/link ~zod %shoe`. You should see

{% code title="Dojo" overflow="nowrap" %}

```
>=
[unlinked from [p=~zod q=%shoe]]
```

{% endcode %}

and if you press `Ctrl-X` you will not get a `~zod:shoe>` prompt. This is because the example app is set up to always allow `~zod` to connect (as well as subject moons if the ship happens to be a planet) but not `~nus`, so this message means that `~nus` failed to connect to `~zod`'s `%shoe` session.

### `%shoe`'s code {#shoes-code}

{% code title="/app/shoe.hoon" overflow="nowrap" %}

```hoon
::  shoe: example usage of /lib/shoe
::
::    the app supports one command: "demo".
::    running this command renders some text on all sole clients.
::
/+  shoe, verb, dbug, default-agent
```

{% endcode %}

`/+` is the Ford rune which imports libraries from the `/lib` directory into the subject.

- `shoe` is the `shoe` library.
- `verb` is a library used to print what a Gall agent is doing.
- `dbug` is a library of debugging tools.
- `default-agent` contains a Gall agent core with minimal implementations of required Gall arms.

{% code title="/app/shoe.hoon" overflow="nowrap" %}

```hoon
|%
+$  state-0  [%0 ~]
+$  command  ~
::
+$  card  card:shoe
--
```

{% endcode %}

The types used by the app.

`state-0` stores the state of the app, which is null as there is no state to keep track of. It is good practice to include a version number anyways, in case the app is made stateful at a later time.

`command` is typically a set of tagged union types that represent the possible commands that can be entered by the user. Since this app only supports one command, it is unnecessary for it to have any associated data, thus the command is represented by `~`.

In a non-trivial context, a `command` is commonly given by `[%name data]`, where `%name` is the identifier for the type of command and `data` is a type or list of types that contain data needed to execute the command. See `app/chat-cli.hoon` for examples of commands, such as `[%say letter:store]` and `[%delete path]`. This is not required though, and you could use something like `[chat-room=@t =action]`.

`card` is either an ordinary Gall agent `card` or a `%shoe` `card`, which takes the shape `[%shoe sole-ids=(list sole-id) effect=shoe-effect]`. A `%shoe` `card` is sent to all sessions listed in `sole-ids`, making them run the `sole-effect` specified by `effect` (i.e. printing some text). Here we can reference `card:shoe` because of `/+ shoe` at the beginning of the app.

{% code title="/app/shoe.hoon" overflow="nowrap" %}

```hoon
=|  state-0
=*  state  -
::
```

{% endcode %}

Add the bunt value of `state-0` to the head of the subject, then give it the macro `state`. The `-` here is a lark expression referring to the head of the subject. This allows us to use `state` to refer to the state elsewhere in the code no matter what version we're using, while also getting direct access to the contents of `state` (if it had any).

{% code title="/app/shoe.hoon" overflow="nowrap" %}

```hoon
%+  verb  |
%-  agent:dbug
^-  agent:gall
%-  (agent:shoe command)
^-  (shoe:shoe command)
```

{% endcode %}

The casts here are just reminders of what is being produced. So let's focus on what the `%` runes are doing, from bottom to top. We call `(agent:shoe command)` on what follows (i.e. the rest of the app), producing a standard Gall agent core. Then we call wrap the Gall agent core with `agent:dbug`, endowing it with additional arms useful for debugging, and then wrap again with `verb`.

{% code title="/app/shoe.hoon" overflow="nowrap" %}

```hoon
|_  =bowl:gall
+*  this  .
    def   ~(. (default-agent this %|) bowl)
    des   ~(. (default:shoe this command) bowl)
```

{% endcode %}

This is boilerplate Gall agent core code. We set `this` to be a macro for the subject, which is the Gall agent core itself. We set `def` and `des` to be macros for initialized `default-agent` and `default:shoe` doors respectively.

Next we implement all of the arms required for a `shoe` agent. Starting with the standard Gall arms:

{% code title="/app/shoe.hoon" overflow="nowrap" %}

```hoon
++  on-init   on-init:def
++  on-save   !>(state)
++  on-load
  |=  old=vase
  ^-  (quip card _this)
  [~ this]
::
++  on-poke   on-poke:def
++  on-watch  on-watch:def
++  on-leave  on-leave:def
++  on-peek   on-peek:def
++  on-agent  on-agent:def
++  on-arvo   on-arvo:def
++  on-fail   on-fail:def
```

{% endcode %}

These are minimalist Gall app arm implementations using the default behavior found in `def`.

Here begins the implementation of the additional arms required by the `(shoe:shoe command)` interface.

{% code title="/app/shoe.hoon" overflow="nowrap" %}

```hoon
++  command-parser
  |=  =sole-id
  ^+  |~(nail *(like [? command]))
  (cold [& ~] (jest 'demo'))
```

{% endcode %}

`+command-parser` is of central importance - it is what is used to parse user input and transform it into `command`s for the app to execute. Writing a proper command parser requires understanding of the Hoon parsing functions found in the standard library. How to do so may be found in the [parsing tutorial](../../../language/hoon/guides/parsing.md). For now, it is sufficient to know that this arm matches the text "demo" and produces a `[? command]`-shaped noun in response. Note how the `&` signifies that the command will be run as soon as it has been entered, without waiting for the user to press return.

{% code title="/app/shoe.hoon" overflow="nowrap" %}

```hoon
++  tab-list
  |=  =sole-id
  ^-  (list [@t tank])
  :~  ['demo' leaf+"run example command"]
  ==
```

{% endcode %}

`+tab-list` is pretty much plug-n-play. For each command you want to be tab completed, add an entry to the `list` begun by `:~` of the form `[%command leaf+"description"]`. Now whenever the user types a partial command and presses tab, the console will display the list of commmands that match the partial command as well as the descriptions given here.

Thus here we have that starting to type `demo` and pressing tab will result in the following output in the console:

{% code title="Dojo" overflow="nowrap" %}

```
demo  run example command
~zod:shoe> demo
```

{% endcode %}

with the remainder of `demo` now added to the input line.

Next we have `+on-command`, which is called whenever `+command-parser` recognizes that `demo` has been entered by a user.

{% code title="/app/shoe.hoon" overflow="nowrap" %}

```hoon
++  on-command
  |=  [=sole-id =command]
  ^-  (quip card _this)
```

{% endcode %}

This is a gate that takes in the `sole-id` corresponding to the session and the `command` noun parsed by `+command-parser` and returns a `list` of `card`s and `_this`, which is our shoe agent core including its state.

{% code title="/app/shoe.hoon" overflow="nowrap" %}

```hoon
  =-  [[%shoe ~ %sole -]~ this]
```

{% endcode %}

This creates a cell of a `%shoe` card that triggers a `sole-effect` given by the head of the subject `-`, then the Gall agent core `this` - i.e. the return result of this gate. The use of the `=-` rune means that what follows this expression is actually run first, which puts the desired `sole-effect` into the head of the subject.

{% code title="/app/shoe.hoon" overflow="nowrap" %}

```hoon
  =/  =tape  "{(scow %p src.bowl)} ran the command"
```

{% endcode %}

We define the `tape` that we want to be printed.

{% code title="/app/shoe.hoon" overflow="nowrap" %}

```hoon
  ?.  =(src our):bowl
    [%txt tape]
  [%klr [[`%br ~ `%g] [(crip tape)]~]~]
```

{% endcode %}

We cannot just produce the `tape` we want printed, - it needs to fit the `sole-effect` type. This tells us that if the origin of the command is not our ship to just print it normally with the `%txt` `sole-effect`. Otherwise we use `%klr`, which prints it stylistically (here it makes the text green and bold).

The following allows either `~zod`, or the host ship and its moons, to connect to this app's command line interface using `|dojo/link`.

{% code title="/app/shoe.hoon" overflow="nowrap" %}

```hoon
++  can-connect
  |=  =sole-id
  ^-  ?
  ?|  =(~zod src.bowl)
      (team:title [our src]:bowl)
  ==
```

{% endcode %}

We use the minimal implementations for the final two `shoe` arms, since we don't want to do anything special when users connect or disconnect.

{% code title="/app/shoe.hoon" overflow="nowrap" %}

```hoon
++  on-connect      on-connect:des
++  on-disconnect   on-disconnect:des
--
```

{% endcode %}

This concludes our review of the code of the `%shoe` app. To continue learning how to build your own CLI app, we recommend checking out `/app/chat-cli.hoon`.
